package main

import (
	"fmt"
	"io"

	"go.temporal.io/server/common/log"
	"go.temporal.io/server/common/log/tag"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	// CurrentVersion means to emit code for the current version of protos.
	CurrentVersion Mode = iota

	// Gogo122Version means to emit code for the older gogo-based protos
	// from Temporal v1.22. The way this works is to walk type hierarchies
	// for current version of protos, but convert the current protos back
	// to the corresponding gogo-based types/packages.
	Gogo122Version
)

type (
	Emitter struct {
		logger        log.Logger
		mode          Mode
		funcSignature string
		handlers      []*Handler
		imports       map[string]struct{}
		extraImports  map[string]struct{}
		root          *Tree
		inScopeVars   map[string]struct{}
		trailer       string
	}

	// Handler can match a field in the type hierarchy
	// and contains a function to generate code for that field
	Handler struct {
		// Include returns whether to
		Include    func(VisitType, VisitPath) bool
		Invocation func(string) string
	}

	Mode int
)

func NewEmitter(logger log.Logger, mode Mode) *Emitter {
	return &Emitter{
		logger:       logger,
		mode:         mode,
		imports:      make(map[string]struct{}),
		extraImports: make(map[string]struct{}),
		root:         NewTree(),
		inScopeVars:  map[string]struct{}{},
	}
}

func (e *Emitter) SetFunctionSignature(sig string) {
	e.funcSignature = sig
}

func (e *Emitter) SetFunctionTrailer(trailer string) {
	e.trailer = trailer
}

func (e *Emitter) AddHandler(include func(vt VisitType, path VisitPath) bool, invocation func(string) string) {
	e.handlers = append(e.handlers, &Handler{
		Include:    include,
		Invocation: invocation,
	})
}

func (e *Emitter) AddImport(s string) {
	e.extraImports[s] = struct{}{}
}

func (e *Emitter) Visit(mt protoreflect.MessageType) {
	Visit(mt.Descriptor(), e.visit)
}

func (e *Emitter) visit(obj VisitType, path VisitPath) bool {
	if e.mode == Gogo122Version && shouldIgnoreTypeIfDoesntExistIn122(obj.Descriptor) {
		return false
	}

	e.logger.Debug("Emitter.visit",
		tag.NewStringTag("obj", string(obj.FullName())),
		tag.NewStringTag("path", path.String()),
	)
	for _, handler := range e.handlers {
		if handler.Include(obj, path) {
			pathCopy := make(VisitPath, len(path))
			copy(pathCopy, path) // path is reused during the visitor / changes as it goes.
			e.root.Insert(pathCopy, handler)
			e.discoverImports(pathCopy)
		}
	}
	return true
}

func (e *Emitter) discoverImports(path VisitPath) {
	for _, obj := range path {
		e.imports[obj.GoImportPath()] = struct{}{}
	}
}

func (e *Emitter) Generate(out io.Writer) {
	e.genPreamble(out)

	if e.funcSignature != "" {
		writeln(out, e.funcSignature+" {")
	} else {
		writeln(out, "func VisitMessage(vAny any) {")
	}
	writeln(out, "switch root := vAny.(type) {")
	for _, typ := range e.root.SortedTypes() {
		writef(out, "case *%s:\n", typ.GoQualifiedName())
		if child := e.root.Children[typ.GoName()]; child != nil {
			e.emit(out, "root", child)
		}
	}
	writeln(out, "}")
	writeln(out, e.trailer)
	writeln(out, "}")
}

func (e *Emitter) genPreamble(out io.Writer) {
	writeln(out, `// Code generated by cmd/tools/genvisitor. DO NOT EDIT.

	package main_test

	import (`)

	for imp := range e.imports {
		alias := getImportAlias(imp)
		if e.mode == Gogo122Version {
			imp = replaceWith122Import(imp)
		}
		writef(out, "%s \"%s\"\n", alias, imp)
	}

	for imp := range e.extraImports {
		writef(out, "\"%s\"\n", imp)

	}
	writeln(out, `)`)
}

func (e *Emitter) emit(out io.Writer, parentVar string, node *Tree) {
	if node == nil {
		return
	}

	for _, vt := range node.SortedTypes() {
		switch desc := vt.Descriptor.(type) {
		case protoreflect.FieldDescriptor:
			if desc.IsMap() {
				varName, freeVar := e.makeVar("val")
				defer freeVar()
				writef(out, "for _, %s := range %s.%s {\n", varName, parentVar, vt.GoGetter())
				e.emit(out, varName, node.Children[vt.GoName()])
				writeln(out, "}")
			} else if desc.IsList() {
				varName, freeVar := e.makeVar("item")
				defer freeVar()
				writef(out, "for _, %s := range %s.%s {\n", varName, parentVar, vt.GoGetter())
				e.emit(out, varName, node.Children[vt.GoName()])
				writeln(out, "}")
			} else {
				varName, freeVar := e.makeVar("y")
				defer freeVar()
				writef(out, "%s := %s.%s\n", varName, parentVar, vt.GoGetter())
				e.emit(out, varName, node.Children[vt.GoName()])
			}
		case protoreflect.OneofDescriptor:
			writef(out, "switch oneof := %s.%s.(type) {\n", parentVar, vt.GoGetter())
			e.emitOneOfCases(out, "oneof", vt, node.Children[vt.GoName()])
			writeln(out, "}")
		default:
			e.emit(out, parentVar, node.Children[vt.GoName()])
		}
	}

	for _, handler := range node.Handlers {
		writeln(out, handler.Invocation(parentVar))
	}
}

func (e *Emitter) emitOneOfCases(out io.Writer, parentVar string, oneof VisitType, node *Tree) {
	for _, vt := range node.SortedTypes() {
		writef(out, "case *%s.%s:\n", oneof.GoPackageName(), getOneofWrapperType(oneof, vt))
		varName, freeVar := e.makeVar("x")
		name := vt.GoName()
		writef(out, "%s := %s.%s\n", varName, parentVar, name)
		e.emit(out, varName, node.Children[vt.GoName()])
		freeVar()
	}
}

func (e *Emitter) makeVar(name string) (string, func()) {
	for i := 1; i < 50; i++ {
		name := fmt.Sprintf("%s%d", name, i)
		if _, ok := e.inScopeVars[name]; !ok {
			e.inScopeVars[name] = struct{}{}
			return name, func() { e.freeVar(name) }
		}
	}
	panic("failed to generate unique variable name")
}

func (e *Emitter) freeVar(name string) {
	delete(e.inScopeVars, name)
}

// Return the "wrapper" Golang interface for `oneof` fields.
//
// Protobuf `oneof` fields are generated as an interface:
//
//		type ReplicationTask struct {
//			Attributes isReplicationTask_Attributes `protobuf_oneof:"attributes"`
//	        ...
//		}
//
// The interface is implemented by "wrapper" types which seemingly do not appear
// in the protobuf reflection registry, so we do not enounter these "wrapper"
// type names while visiting the protobuf type hierachy.
//
//	 type ReplicationTask_SyncVersionedTransitionTaskAttributes struct {
//		  SyncVersionedTransitionTaskAttributes *SyncVersionedTransitionTaskAttributes
//	 }
//
// This returns the implementing type, e.g. "ReplicationTask_SyncVersionedTransitionTaskAttributes",
// given the interface field (e.g. `Attributes`) and the wrapped field (e.g. `SyncVersionedTransitionTaskAttributes`)
func getOneofWrapperType(oneof, typ VisitType) string {
	return string(oneof.Parent().Name()) + "_" + snakeToPascalCase(typ.Name())
}
